{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["export interface AnyAction {\n  type: any;\n}\n\nexport type Meta = null | { [key: string]: any };\n\nexport interface Action<Payload> extends AnyAction {\n  type: string;\n  payload: Payload;\n  error?: boolean;\n  meta?: Meta;\n}\n\n/**\n * Returns `true` if action has the same type as action creator.\n * Defines Type Guard that lets TypeScript know `payload` type inside blocks\n * where `isType` returned `true`.\n *\n * @example\n *\n *    const somethingHappened =\n *      actionCreator<{foo: string}>('SOMETHING_HAPPENED');\n *\n *    if (isType(action, somethingHappened)) {\n *      // action.payload has type {foo: string}\n *    }\n */\nexport function isType<Payload>(\n  action: AnyAction,\n  actionCreator: ActionCreator<Payload>,\n): action is Action<Payload> {\n  return action.type === actionCreator.type;\n}\n\nexport interface ActionCreator<Payload> {\n  type: string;\n  /**\n   * Identical to `isType` except it is exposed as a bound method of an action\n   * creator. Since it is bound and takes a single argument it is ideal for\n   * passing to a filtering function like `Array.prototype.filter` or\n   * RxJS's `Observable.prototype.filter`.\n   *\n   * @example\n   *\n   *    const somethingHappened =\n   *      actionCreator<{foo: string}>('SOMETHING_HAPPENED');\n   *    const somethingElseHappened =\n   *      actionCreator<{bar: number}>('SOMETHING_ELSE_HAPPENED');\n   *\n   *    if (somethingHappened.match(action)) {\n   *      // action.payload has type {foo: string}\n   *    }\n   *\n   *    const actionArray = [\n   *      somethingHappened({foo: 'foo'}),\n   *      somethingElseHappened({bar: 5}),\n   *    ];\n   *\n   *    // somethingHappenedArray has inferred type Action<{foo: string}>[]\n   *    const somethingHappenedArray =\n   *      actionArray.filter(somethingHappened.match);\n   */\n  match: (action: AnyAction) => action is Action<Payload>;\n\n  /**\n   * Creates action with given payload and metadata.\n   *\n   * @param payload Action payload.\n   * @param meta Action metadata. Merged with `commonMeta` of Action Creator.\n   */\n  (payload: Payload, meta?: Meta): Action<Payload>;\n}\n\nexport type Success<Params, Result> = (\n  | { params: Params }\n  | (Params extends void ? { params?: Params } : never)\n) &\n  ({ result: Result } | (Result extends void ? { result?: Result } : never));\n\nexport type Optimistic<Params, Result> = (\n  | { params: Params }\n  | (Params extends void ? { params?: Params } : never)\n) &\n  ({ result: Result } | (Result extends void ? { result?: Result } : never));\n\nexport type Failure<Params, Error> = (\n  | { params: Params }\n  | (Params extends void ? { params?: Params } : never)\n) & { error: Error };\n\nexport interface AsyncActionCreators<\n  Params,\n  Result,\n  Error = unknown,\n  PreResult = unknown,\n> {\n  type: string;\n  started: ActionCreator<Params>;\n  done: ActionCreator<Success<Params, Result>>;\n  optimistic: ActionCreator<Optimistic<Params, PreResult>>;\n  failed: ActionCreator<Failure<Params, Error>>;\n}\n\nexport interface ActionCreatorFactory {\n  /**\n   * Creates Action Creator that produces actions with given `type` and payload\n   * of type `Payload`.\n   *\n   * @param type Type of created actions.\n   * @param commonMeta Metadata added to created actions.\n   * @param isError Defines whether created actions are error actions.\n   */ <Payload = void>(\n    type: string,\n    commonMeta?: Meta,\n    isError?: boolean,\n  ): ActionCreator<Payload>;\n\n  /**\n   * Creates Action Creator that produces actions with given `type` and payload\n   * of type `Payload`.\n   *\n   * @param type Type of created actions.\n   * @param commonMeta Metadata added to created actions.\n   * @param isError Function that detects whether action is error given the\n   *   payload.\n   */ <Payload = void>(\n    type: string,\n    commonMeta?: Meta,\n    isError?: (payload: Payload) => boolean,\n  ): ActionCreator<Payload>;\n\n  /**\n   * Creates three Action Creators:\n   * * `started: ActionCreator<Params>`\n   * * `done: ActionCreator<{params: Params, result: Result}>`\n   * * `failed: ActionCreator<{params: Params, error: Error}>`\n   *\n   * Useful to wrap asynchronous processes.\n   *\n   * @param type Prefix for types of created actions, which will have types\n   *   `${type}_STARTED`, `${type}_DONE` and `${type}_FAILED`.\n   * @param commonMeta Metadata added to created actions.\n   */\n  async<Params, Result, Error = unknown, PreResult = unknown>(\n    type: string,\n    commonMeta?: Meta,\n  ): AsyncActionCreators<Params, Result, Error, PreResult>;\n}\n\ndeclare const process: {\n  env: {\n    NODE_ENV?: string;\n  };\n};\n\n/**\n * Creates Action Creator factory with optional prefix for action types.\n * @param prefix Prefix to be prepended to action types as `<prefix>/<type>`.\n * @param defaultIsError Function that detects whether action is error given the\n *   payload. Default is `payload => payload instanceof Error`.\n */\nexport function actionCreatorFactory(\n  prefix?: string | null,\n  defaultIsError: (payload: any) => boolean = (p) => p instanceof Error,\n): ActionCreatorFactory {\n  const actionTypes: { [type: string]: boolean } = {};\n\n  const base = prefix ? `${prefix}/` : '';\n\n  function actionCreator<Payload>(\n    type: string,\n    commonMeta?: Meta,\n    isError: ((payload: Payload) => boolean) | boolean = defaultIsError,\n  ) {\n    const fullType = base + type;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (actionTypes[fullType])\n        throw new Error(`Duplicate action type: ${fullType}`);\n\n      actionTypes[fullType] = true;\n    }\n\n    return Object.assign(\n      (payload: Payload, meta?: Meta) => {\n        const action: Action<Payload> = {\n          type: fullType,\n          payload,\n        };\n\n        if (commonMeta || meta) {\n          action.meta = Object.assign({}, commonMeta, meta);\n        }\n\n        if (isError && (typeof isError === 'boolean' || isError(payload))) {\n          action.error = true;\n        }\n\n        return action;\n      },\n      {\n        type: fullType,\n        toString: () => fullType,\n        match: (action: AnyAction): action is Action<Payload> =>\n          action.type === fullType,\n      },\n    ) as ActionCreator<Payload>;\n  }\n\n  function asyncActionCreators<Params, Result, Error, PreResult>(\n    type: string,\n    commonMeta?: Meta,\n  ): AsyncActionCreators<Params, Result, Error, PreResult> {\n    return {\n      type: base + type,\n      started: actionCreator<Params>(`${type}_STARTED`, commonMeta, false),\n      done: actionCreator<Success<Params, Result>>(\n        `${type}_DONE`,\n        commonMeta,\n        false,\n      ),\n      optimistic: actionCreator<Optimistic<Params, PreResult>>(\n        `${type}_OPTIMISTIC`,\n        commonMeta,\n        false,\n      ),\n      failed: actionCreator<Failure<Params, Error>>(\n        `${type}_FAILED`,\n        commonMeta,\n        true,\n      ),\n    };\n  }\n\n  return Object.assign(actionCreator, { async: asyncActionCreators });\n}\n\nexport default actionCreatorFactory;\n"],"names":[],"mappings":"AAAO,SAAS,MAAM,CAAC,MAAM,EAAE,aAAa,EAAE;AAC9C,EAAE,OAAO,MAAM,CAAC,IAAI,KAAK,aAAa,CAAC,IAAI,CAAC;AAC5C,CAAC;AACM,SAAS,oBAAoB,CAAC,MAAM,EAAE,cAAc,GAAG,CAAC,CAAC,KAAK,CAAC,YAAY,KAAK,EAAE;AACzF,EAAE,MAAM,WAAW,GAAG,EAAE,CAAC;AACzB,EAAE,MAAM,IAAI,GAAG,MAAM,GAAG,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;AAC1C,EAAE,SAAS,aAAa,CAAC,IAAI,EAAE,UAAU,EAAE,OAAO,GAAG,cAAc,EAAE;AACrE,IAAI,MAAM,QAAQ,GAAG,IAAI,GAAG,IAAI,CAAC;AACjC,IAAI,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,EAAE;AAC/C,MAAM,IAAI,WAAW,CAAC,QAAQ,CAAC;AAC/B,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,uBAAuB,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;AAC9D,MAAM,WAAW,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC;AACnC,KAAK;AACL,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,IAAI,KAAK;AAC5C,MAAM,MAAM,MAAM,GAAG;AACrB,QAAQ,IAAI,EAAE,QAAQ;AACtB,QAAQ,OAAO;AACf,OAAO,CAAC;AACR,MAAM,IAAI,UAAU,IAAI,IAAI,EAAE;AAC9B,QAAQ,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;AAC1D,OAAO;AACP,MAAM,IAAI,OAAO,KAAK,OAAO,OAAO,KAAK,SAAS,IAAI,OAAO,CAAC,OAAO,CAAC,CAAC,EAAE;AACzE,QAAQ,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC;AAC5B,OAAO;AACP,MAAM,OAAO,MAAM,CAAC;AACpB,KAAK,EAAE;AACP,MAAM,IAAI,EAAE,QAAQ;AACpB,MAAM,QAAQ,EAAE,MAAM,QAAQ;AAC9B,MAAM,KAAK,EAAE,CAAC,MAAM,KAAK,MAAM,CAAC,IAAI,KAAK,QAAQ;AACjD,KAAK,CAAC,CAAC;AACP,GAAG;AACH,EAAE,SAAS,mBAAmB,CAAC,IAAI,EAAE,UAAU,EAAE;AACjD,IAAI,OAAO;AACX,MAAM,IAAI,EAAE,IAAI,GAAG,IAAI;AACvB,MAAM,OAAO,EAAE,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC;AAClE,MAAM,IAAI,EAAE,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC;AAC5D,MAAM,UAAU,EAAE,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,EAAE,UAAU,EAAE,KAAK,CAAC;AACxE,MAAM,MAAM,EAAE,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,EAAE,UAAU,EAAE,IAAI,CAAC;AAC/D,KAAK,CAAC;AACN,GAAG;AACH,EAAE,OAAO,MAAM,CAAC,MAAM,CAAC,aAAa,EAAE,EAAE,KAAK,EAAE,mBAAmB,EAAE,CAAC,CAAC;AACtE;;;;"}